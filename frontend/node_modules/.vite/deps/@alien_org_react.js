import {
  require_jsx_runtime
} from "./chunk-S725DACQ.js";
import {
  require_react
} from "./chunk-RLJ2RCJQ.js";
import {
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/emittery/maps.js
var anyMap = /* @__PURE__ */ new WeakMap();
var eventsMap = /* @__PURE__ */ new WeakMap();
var producersMap = /* @__PURE__ */ new WeakMap();

// node_modules/emittery/index.js
var anyProducer = Symbol("anyProducer");
var resolvedPromise = Promise.resolve();
var listenerAdded = Symbol("listenerAdded");
var listenerRemoved = Symbol("listenerRemoved");
var canEmitMetaEvents = false;
var isGlobalDebugEnabled = false;
var isEventKeyType = (key) => typeof key === "string" || typeof key === "symbol" || typeof key === "number";
function assertEventName(eventName) {
  if (!isEventKeyType(eventName)) {
    throw new TypeError("`eventName` must be a string, symbol, or number");
  }
}
function assertListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError("listener must be a function");
  }
}
function getListeners(instance, eventName) {
  const events = eventsMap.get(instance);
  if (!events.has(eventName)) {
    return;
  }
  return events.get(eventName);
}
function getEventProducers(instance, eventName) {
  const key = isEventKeyType(eventName) ? eventName : anyProducer;
  const producers = producersMap.get(instance);
  if (!producers.has(key)) {
    return;
  }
  return producers.get(key);
}
function enqueueProducers(instance, eventName, eventData) {
  const producers = producersMap.get(instance);
  if (producers.has(eventName)) {
    for (const producer of producers.get(eventName)) {
      producer.enqueue(eventData);
    }
  }
  if (producers.has(anyProducer)) {
    const item = Promise.all([eventName, eventData]);
    for (const producer of producers.get(anyProducer)) {
      producer.enqueue(item);
    }
  }
}
function iterator(instance, eventNames) {
  eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
  let isFinished = false;
  let flush = () => {
  };
  let queue = [];
  const producer = {
    enqueue(item) {
      queue.push(item);
      flush();
    },
    finish() {
      isFinished = true;
      flush();
    }
  };
  for (const eventName of eventNames) {
    let set = getEventProducers(instance, eventName);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      const producers = producersMap.get(instance);
      producers.set(eventName, set);
    }
    set.add(producer);
  }
  return {
    async next() {
      if (!queue) {
        return { done: true };
      }
      if (queue.length === 0) {
        if (isFinished) {
          queue = void 0;
          return this.next();
        }
        await new Promise((resolve) => {
          flush = resolve;
        });
        return this.next();
      }
      return {
        done: false,
        value: await queue.shift()
      };
    },
    async return(value) {
      queue = void 0;
      for (const eventName of eventNames) {
        const set = getEventProducers(instance, eventName);
        if (set) {
          set.delete(producer);
          if (set.size === 0) {
            const producers = producersMap.get(instance);
            producers.delete(eventName);
          }
        }
      }
      flush();
      return arguments.length > 0 ? { done: true, value: await value } : { done: true };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function defaultMethodNamesOrAssert(methodNames) {
  if (methodNames === void 0) {
    return allEmitteryMethods;
  }
  if (!Array.isArray(methodNames)) {
    throw new TypeError("`methodNames` must be an array of strings");
  }
  for (const methodName of methodNames) {
    if (!allEmitteryMethods.includes(methodName)) {
      if (typeof methodName !== "string") {
        throw new TypeError("`methodNames` element must be a string");
      }
      throw new Error(`${methodName} is not Emittery method`);
    }
  }
  return methodNames;
}
var isMetaEvent = (eventName) => eventName === listenerAdded || eventName === listenerRemoved;
function emitMetaEvent(emitter2, eventName, eventData) {
  if (!isMetaEvent(eventName)) {
    return;
  }
  try {
    canEmitMetaEvents = true;
    emitter2.emit(eventName, eventData);
  } finally {
    canEmitMetaEvents = false;
  }
}
var Emittery = class _Emittery {
  static mixin(emitteryPropertyName, methodNames) {
    methodNames = defaultMethodNamesOrAssert(methodNames);
    return (target) => {
      if (typeof target !== "function") {
        throw new TypeError("`target` must be function");
      }
      for (const methodName of methodNames) {
        if (target.prototype[methodName] !== void 0) {
          throw new Error(`The property \`${methodName}\` already exists on \`target\``);
        }
      }
      function getEmitteryProperty() {
        Object.defineProperty(this, emitteryPropertyName, {
          enumerable: false,
          value: new _Emittery()
        });
        return this[emitteryPropertyName];
      }
      Object.defineProperty(target.prototype, emitteryPropertyName, {
        enumerable: false,
        get: getEmitteryProperty
      });
      const emitteryMethodCaller = (methodName) => function(...args) {
        return this[emitteryPropertyName][methodName](...args);
      };
      for (const methodName of methodNames) {
        Object.defineProperty(target.prototype, methodName, {
          enumerable: false,
          value: emitteryMethodCaller(methodName)
        });
      }
      return target;
    };
  }
  static get isDebugEnabled() {
    var _a;
    if (typeof ((_a = globalThis.process) == null ? void 0 : _a.env) !== "object") {
      return isGlobalDebugEnabled;
    }
    const { env } = globalThis.process ?? { env: {} };
    return env.DEBUG === "emittery" || env.DEBUG === "*" || isGlobalDebugEnabled;
  }
  static set isDebugEnabled(newValue) {
    isGlobalDebugEnabled = newValue;
  }
  constructor(options = {}) {
    anyMap.set(this, /* @__PURE__ */ new Set());
    eventsMap.set(this, /* @__PURE__ */ new Map());
    producersMap.set(this, /* @__PURE__ */ new Map());
    producersMap.get(this).set(anyProducer, /* @__PURE__ */ new Set());
    this.debug = options.debug ?? {};
    if (this.debug.enabled === void 0) {
      this.debug.enabled = false;
    }
    if (!this.debug.logger) {
      this.debug.logger = (type, debugName, eventName, eventData) => {
        try {
          eventData = JSON.stringify(eventData);
        } catch {
          eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(",")}`;
        }
        if (typeof eventName === "symbol" || typeof eventName === "number") {
          eventName = eventName.toString();
        }
        const currentTime = /* @__PURE__ */ new Date();
        const logTime = `${currentTime.getHours()}:${currentTime.getMinutes()}:${currentTime.getSeconds()}.${currentTime.getMilliseconds()}`;
        console.log(`[${logTime}][emittery:${type}][${debugName}] Event Name: ${eventName}
	data: ${eventData}`);
      };
    }
  }
  logIfDebugEnabled(type, eventName, eventData) {
    if (_Emittery.isDebugEnabled || this.debug.enabled) {
      this.debug.logger(type, this.debug.name, eventName, eventData);
    }
  }
  on(eventNames, listener, { signal } = {}) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      let set = getListeners(this, eventName);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        const events = eventsMap.get(this);
        events.set(eventName, set);
      }
      set.add(listener);
      this.logIfDebugEnabled("subscribe", eventName, void 0);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerAdded, { eventName, listener });
      }
    }
    const off2 = () => {
      this.off(eventNames, listener);
      signal == null ? void 0 : signal.removeEventListener("abort", off2);
    };
    signal == null ? void 0 : signal.addEventListener("abort", off2, { once: true });
    if (signal == null ? void 0 : signal.aborted) {
      off2();
    }
    return off2;
  }
  off(eventNames, listener) {
    assertListener(listener);
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
      const set = getListeners(this, eventName);
      if (set) {
        set.delete(listener);
        if (set.size === 0) {
          const events = eventsMap.get(this);
          events.delete(eventName);
        }
      }
      this.logIfDebugEnabled("unsubscribe", eventName, void 0);
      if (!isMetaEvent(eventName)) {
        emitMetaEvent(this, listenerRemoved, { eventName, listener });
      }
    }
  }
  once(eventNames, predicate) {
    if (predicate !== void 0 && typeof predicate !== "function") {
      throw new TypeError("predicate must be a function");
    }
    let off_;
    const promise = new Promise((resolve) => {
      off_ = this.on(eventNames, (data) => {
        if (predicate && !predicate(data)) {
          return;
        }
        off_();
        resolve(data);
      });
    });
    promise.off = off_;
    return promise;
  }
  events(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      assertEventName(eventName);
    }
    return iterator(this, eventNames);
  }
  async emit(eventName, eventData) {
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
    }
    this.logIfDebugEnabled("emit", eventName, eventData);
    enqueueProducers(this, eventName, eventData);
    const listeners = getListeners(this, eventName) ?? /* @__PURE__ */ new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = isMetaEvent(eventName) ? [] : [...anyListeners];
    await resolvedPromise;
    await Promise.all([
      ...staticListeners.map(async (listener) => {
        if (listeners.has(listener)) {
          return listener(eventData);
        }
      }),
      ...staticAnyListeners.map(async (listener) => {
        if (anyListeners.has(listener)) {
          return listener(eventName, eventData);
        }
      })
    ]);
  }
  async emitSerial(eventName, eventData) {
    assertEventName(eventName);
    if (isMetaEvent(eventName) && !canEmitMetaEvents) {
      throw new TypeError("`eventName` cannot be meta event `listenerAdded` or `listenerRemoved`");
    }
    this.logIfDebugEnabled("emitSerial", eventName, eventData);
    const listeners = getListeners(this, eventName) ?? /* @__PURE__ */ new Set();
    const anyListeners = anyMap.get(this);
    const staticListeners = [...listeners];
    const staticAnyListeners = [...anyListeners];
    await resolvedPromise;
    for (const listener of staticListeners) {
      if (listeners.has(listener)) {
        await listener(eventData);
      }
    }
    for (const listener of staticAnyListeners) {
      if (anyListeners.has(listener)) {
        await listener(eventName, eventData);
      }
    }
  }
  onAny(listener, { signal } = {}) {
    assertListener(listener);
    this.logIfDebugEnabled("subscribeAny", void 0, void 0);
    anyMap.get(this).add(listener);
    emitMetaEvent(this, listenerAdded, { listener });
    const offAny = () => {
      this.offAny(listener);
      signal == null ? void 0 : signal.removeEventListener("abort", offAny);
    };
    signal == null ? void 0 : signal.addEventListener("abort", offAny, { once: true });
    if (signal == null ? void 0 : signal.aborted) {
      offAny();
    }
    return offAny;
  }
  anyEvent() {
    return iterator(this);
  }
  offAny(listener) {
    assertListener(listener);
    this.logIfDebugEnabled("unsubscribeAny", void 0, void 0);
    emitMetaEvent(this, listenerRemoved, { listener });
    anyMap.get(this).delete(listener);
  }
  clearListeners(eventNames) {
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    for (const eventName of eventNames) {
      this.logIfDebugEnabled("clear", eventName, void 0);
      if (isEventKeyType(eventName)) {
        const set = getListeners(this, eventName);
        if (set) {
          set.clear();
        }
        const producers = getEventProducers(this, eventName);
        if (producers) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
        }
      } else {
        anyMap.get(this).clear();
        for (const [eventName2, listeners] of eventsMap.get(this).entries()) {
          listeners.clear();
          eventsMap.get(this).delete(eventName2);
        }
        for (const [eventName2, producers] of producersMap.get(this).entries()) {
          for (const producer of producers) {
            producer.finish();
          }
          producers.clear();
          producersMap.get(this).delete(eventName2);
        }
      }
    }
  }
  listenerCount(eventNames) {
    var _a, _b, _c;
    eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
    let count = 0;
    for (const eventName of eventNames) {
      if (isEventKeyType(eventName)) {
        count += anyMap.get(this).size + (((_a = getListeners(this, eventName)) == null ? void 0 : _a.size) ?? 0) + (((_b = getEventProducers(this, eventName)) == null ? void 0 : _b.size) ?? 0) + (((_c = getEventProducers(this)) == null ? void 0 : _c.size) ?? 0);
        continue;
      }
      if (eventName !== void 0) {
        assertEventName(eventName);
      }
      count += anyMap.get(this).size;
      for (const value of eventsMap.get(this).values()) {
        count += value.size;
      }
      for (const value of producersMap.get(this).values()) {
        count += value.size;
      }
    }
    return count;
  }
  bindMethods(target, methodNames) {
    if (typeof target !== "object" || target === null) {
      throw new TypeError("`target` must be an object");
    }
    methodNames = defaultMethodNamesOrAssert(methodNames);
    for (const methodName of methodNames) {
      if (target[methodName] !== void 0) {
        throw new Error(`The property \`${methodName}\` already exists on \`target\``);
      }
      Object.defineProperty(target, methodName, {
        enumerable: false,
        value: this[methodName].bind(this)
      });
    }
  }
};
var allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter((v) => v !== "constructor");
Object.defineProperty(Emittery, "listenerAdded", {
  value: listenerAdded,
  writable: false,
  enumerable: true,
  configurable: false
});
Object.defineProperty(Emittery, "listenerRemoved", {
  value: listenerRemoved,
  writable: false,
  enumerable: true,
  configurable: false
});

// node_modules/@alien_org/contract/dist/index.mjs
var PLATFORMS = ["ios", "android"];
var releases = {
  "0.0.9": ["app:ready"],
  "0.0.14": ["miniapp:close.ack", "host.back.button:toggle"],
  "0.1.1": [
    "payment:request",
    "clipboard:write",
    "clipboard:read"
  ],
  "0.1.3": ["link:open"]
};
function isMethodSupported(method, version) {
  const methods = releases[version];
  if (!methods) return false;
  return methods.some((m) => typeof m === "string" ? m === method : m.method === method);
}
function getMethodMinVersion(method) {
  const sorted = Object.keys(releases).sort((a, b) => {
    const [aMajor, aMinor, aPatch] = a.split(".").map(Number);
    const [bMajor, bMinor, bPatch] = b.split(".").map(Number);
    if (aMajor !== bMajor) return (aMajor ?? 0) - (bMajor ?? 0);
    if (aMinor !== bMinor) return (aMinor ?? 0) - (bMinor ?? 0);
    return (aPatch ?? 0) - (bPatch ?? 0);
  });
  for (const version of sorted) {
    const methods = releases[version];
    if (!methods) continue;
    if (methods.some((m) => typeof m === "string" ? m === method : m.method === method)) return version;
  }
}

// node_modules/@alien_org/bridge/dist/index.mjs
var BridgeError = class BridgeError2 extends Error {
  constructor(message) {
    super(message);
    this.name = "BridgeError";
    if (Error.captureStackTrace) Error.captureStackTrace(this, BridgeError2);
  }
};
var BridgeUnavailableError = class extends BridgeError {
  constructor() {
    super("Bridge is not available. This SDK requires Alien App environment.");
    this.name = "BridgeUnavailableError";
  }
};
var BridgeWindowUnavailableError = class extends BridgeError {
  constructor() {
    super("Window is not available. This SDK requires a browser environment.");
    this.name = "BridgeWindowUnavailableError";
  }
};
var BridgeTimeoutError = class extends BridgeError {
  constructor(method, timeout) {
    super(`Request timeout: ${method} (${timeout}ms)`);
    __publicField(this, "method");
    __publicField(this, "timeout");
    this.name = "BridgeTimeoutError";
    this.method = method;
    this.timeout = timeout;
  }
};
function getBridge() {
  if (typeof window === "undefined") return;
  const bridge = window.__miniAppsBridge__;
  if (!bridge || typeof bridge.postMessage !== "function") return;
  return bridge;
}
function sendMessage(message) {
  const bridge = getBridge();
  if (!bridge) throw new BridgeUnavailableError();
  bridge.postMessage(JSON.stringify(message));
}
function isMessage(data) {
  return data !== null && typeof data === "object" && "type" in data && "name" in data && "payload" in data && (data.type === "event" || data.type === "method");
}
function setupMessageListener(handler) {
  if (typeof window === "undefined") return () => {
  };
  const messageHandler = (event) => {
    let data = event.data;
    if (typeof data === "string") try {
      data = JSON.parse(data);
    } catch {
      return;
    }
    if (isMessage(data)) handler(data);
  };
  window.addEventListener("message", messageHandler);
  return () => {
    window.removeEventListener("message", messageHandler);
  };
}
var BridgeEmitter = class extends Emittery {
  constructor() {
    super();
    setupMessageListener((message) => {
      if (message.type === "event") this.emit(message.name, message.payload);
    });
  }
};
var emitter = new BridgeEmitter();
function on(name, listener) {
  emitter.on(name, listener);
  return () => {
    emitter.off(name, listener);
  };
}
function off(name, listener) {
  emitter.off(name, listener);
}
var SESSION_STORAGE_KEY = "alien/launchParams";
var LaunchParamsError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "LaunchParamsError";
  }
};
function validateVersion(value) {
  if (!value) return void 0;
  return /^\d+\.\d+\.\d+$/.test(value) ? value : void 0;
}
function validatePlatform(value) {
  if (!value) return void 0;
  return PLATFORMS.includes(value) ? value : void 0;
}
function retrieveFromWindow() {
  if (typeof window === "undefined") return null;
  if (window.__ALIEN_AUTH_TOKEN__ === void 0) return null;
  return {
    authToken: window.__ALIEN_AUTH_TOKEN__,
    contractVersion: validateVersion(window.__ALIEN_CONTRACT_VERSION__),
    hostAppVersion: window.__ALIEN_HOST_VERSION__,
    platform: validatePlatform(window.__ALIEN_PLATFORM__),
    startParam: window.__ALIEN_START_PARAM__
  };
}
function retrieveFromSessionStorage() {
  if (typeof window === "undefined") return null;
  try {
    const raw = sessionStorage.getItem(SESSION_STORAGE_KEY);
    if (!raw) return null;
    return parseLaunchParams(raw);
  } catch {
    return null;
  }
}
function persistToSessionStorage(params) {
  try {
    sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(params));
  } catch {
  }
}
function parseLaunchParams(raw) {
  const parsed = JSON.parse(raw);
  return {
    authToken: parsed.authToken,
    contractVersion: validateVersion(parsed.contractVersion),
    hostAppVersion: parsed.hostAppVersion,
    platform: validatePlatform(parsed.platform),
    startParam: parsed.startParam
  };
}
function retrieveLaunchParams() {
  const fromWindow = retrieveFromWindow();
  if (fromWindow) {
    persistToSessionStorage(fromWindow);
    return fromWindow;
  }
  const fromStorage = retrieveFromSessionStorage();
  if (fromStorage) return fromStorage;
  throw new LaunchParamsError("Launch params not available. Running outside Alien App? Use mockLaunchParamsForDev() for development.");
}
function getLaunchParams() {
  try {
    return retrieveLaunchParams();
  } catch {
    return;
  }
}
var DEFAULT_TIMEOUT = 3e4;
function generateReqId() {
  return typeof crypto !== "undefined" && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
}
async function request(method, params, responseEvent, options = {}) {
  const reqId = options.reqId || generateReqId();
  const timeout = options.timeout || DEFAULT_TIMEOUT;
  const payload = {
    ...params,
    reqId
  };
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      cleanup();
      reject(new BridgeTimeoutError(String(method), timeout));
    }, timeout);
    const cleanup = () => {
      clearTimeout(timeoutId);
      off(responseEvent, handleResponse);
    };
    const handleResponse = (payload$1) => {
      if (payload$1.reqId === reqId) {
        cleanup();
        resolve(payload$1);
      }
    };
    on(responseEvent, handleResponse);
    sendMessage({
      type: "method",
      name: method,
      payload
    });
  });
}
function send(method, payload) {
  sendMessage({
    type: "method",
    name: method,
    payload
  });
}
function isBridgeAvailable() {
  return getBridge() !== void 0;
}

// node_modules/@alien_org/react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var AlienContext = (0, import_react.createContext)(null);
function AlienProvider({ children }) {
  const value = (0, import_react.useMemo)(() => {
    const launchParams = getLaunchParams();
    return {
      authToken: launchParams == null ? void 0 : launchParams.authToken,
      contractVersion: launchParams == null ? void 0 : launchParams.contractVersion,
      isBridgeAvailable: isBridgeAvailable()
    };
  }, []);
  (0, import_react.useEffect)(() => {
    if (!value.isBridgeAvailable) console.warn("[@alien_org/react] Bridge is not available. Running in dev mode? The SDK will handle errors gracefully, but bridge communication will not work.");
  }, [value.isBridgeAvailable]);
  (0, import_react.useEffect)(() => {
    if (value.isBridgeAvailable) send("app:ready", {});
  }, [value.isBridgeAvailable]);
  return (0, import_jsx_runtime.jsx)(AlienContext.Provider, {
    value,
    children
  });
}
var ReactSDKError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ReactSDKError";
  }
};
var MethodNotSupportedError = class extends ReactSDKError {
  constructor(method, contractVersion, minVersion) {
    const message = minVersion ? `Method "${method}" requires version ${minVersion}, but host provides ${contractVersion ?? "unknown"}` : `Method "${method}" is not supported`;
    super(message);
    __publicField(this, "method");
    __publicField(this, "contractVersion");
    __publicField(this, "minVersion");
    this.name = "MethodNotSupportedError";
    this.method = method;
    this.contractVersion = contractVersion;
    this.minVersion = minVersion;
  }
};
function useAlien() {
  const context = (0, import_react.useContext)(AlienContext);
  if (!context) throw new Error("useAlien must be used within an AlienProvider");
  return context;
}
function useClipboard(options = {}) {
  const { timeout = 5e3 } = options;
  const { contractVersion, isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
  const [isReading, setIsReading] = (0, import_react.useState)(false);
  const [errorCode, setErrorCode] = (0, import_react.useState)(null);
  const supported = contractVersion ? isMethodSupported("clipboard:write", contractVersion) && isMethodSupported("clipboard:read", contractVersion) : true;
  const writeText = (0, import_react.useCallback)((text) => {
    if (!isBridgeAvailable$1) return;
    if (contractVersion && !isMethodSupported("clipboard:write", contractVersion)) return;
    send("clipboard:write", { text });
  }, [isBridgeAvailable$1, contractVersion]);
  const readText = (0, import_react.useCallback)(async () => {
    if (!isBridgeAvailable$1) return null;
    if (contractVersion && !isMethodSupported("clipboard:read", contractVersion)) return null;
    setIsReading(true);
    setErrorCode(null);
    try {
      const response = await request("clipboard:read", {}, "clipboard:response", { timeout });
      if (response.errorCode) {
        setErrorCode(response.errorCode);
        return null;
      }
      return response.text;
    } catch {
      return null;
    } finally {
      setIsReading(false);
    }
  }, [
    isBridgeAvailable$1,
    contractVersion,
    timeout
  ]);
  return (0, import_react.useMemo)(() => ({
    writeText,
    readText,
    isReading,
    errorCode,
    supported
  }), [
    writeText,
    readText,
    isReading,
    errorCode,
    supported
  ]);
}
function useEvent(event, callback) {
  const callbackRef = (0, import_react.useRef)(callback);
  callbackRef.current = callback;
  const { isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
  (0, import_react.useEffect)(() => {
    if (!isBridgeAvailable$1) {
      console.warn("[@alien_org/react] Bridge is not available. Event listener will not be set up. Running in dev mode?");
      return;
    }
    const handler = (payload) => {
      callbackRef.current(payload);
    };
    try {
      return on(event, handler);
    } catch (error) {
      console.warn("[@alien_org/react] Failed to set up event listener:", error instanceof Error ? error.message : String(error));
      return;
    }
  }, [event, isBridgeAvailable$1]);
}
function useIsMethodSupported(method) {
  const { contractVersion } = useAlien();
  return {
    supported: contractVersion ? isMethodSupported(method, contractVersion) : true,
    contractVersion,
    minVersion: getMethodMinVersion(method)
  };
}
function useLaunchParams() {
  return (0, import_react.useMemo)(() => getLaunchParams(), []);
}
function useMethod(method, responseEvent, options = {}) {
  const { checkVersion = true } = options;
  const { contractVersion, isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
  const [state, setState] = (0, import_react.useState)({
    data: void 0,
    error: void 0,
    isLoading: false
  });
  const supported = contractVersion ? isMethodSupported(method, contractVersion) : true;
  const execute = (0, import_react.useCallback)(async (params, requestOptions) => {
    if (!isBridgeAvailable$1) {
      const error = new Error("Bridge is not available. Running in dev mode? Bridge communication will not work.");
      console.warn("[@alien_org/react]", error.message);
      setState({
        data: void 0,
        error,
        isLoading: false
      });
      return {
        data: void 0,
        error
      };
    }
    if (checkVersion) {
      if (contractVersion && !isMethodSupported(method, contractVersion)) {
        const error = new MethodNotSupportedError(method, contractVersion, getMethodMinVersion(method));
        setState({
          data: void 0,
          error,
          isLoading: false
        });
        return {
          data: void 0,
          error
        };
      }
    }
    setState({
      data: void 0,
      error: void 0,
      isLoading: true
    });
    try {
      const response = await request(method, params, responseEvent, requestOptions);
      setState({
        data: response,
        error: void 0,
        isLoading: false
      });
      return {
        data: response,
        error: void 0
      };
    } catch (err) {
      if (err instanceof BridgeError) {
        console.warn("[@alien_org/react] Bridge error:", err.message);
        setState({
          data: void 0,
          error: err,
          isLoading: false
        });
        return {
          data: void 0,
          error: err
        };
      }
      const error = err instanceof Error ? err : new Error(String(err));
      setState({
        data: void 0,
        error,
        isLoading: false
      });
      return {
        data: void 0,
        error
      };
    }
  }, [
    method,
    responseEvent,
    checkVersion,
    contractVersion,
    isBridgeAvailable$1
  ]);
  const reset = (0, import_react.useCallback)(() => {
    setState({
      data: void 0,
      error: void 0,
      isLoading: false
    });
  }, []);
  return (0, import_react.useMemo)(() => ({
    ...state,
    execute,
    reset,
    supported
  }), [
    state,
    execute,
    reset,
    supported
  ]);
}
function usePayment(options = {}) {
  const { timeout = 12e4, onPaid, onCancelled, onFailed, onStatusChange } = options;
  const { contractVersion, isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
  const callbacksRef = (0, import_react.useRef)({
    onPaid,
    onCancelled,
    onFailed,
    onStatusChange
  });
  callbacksRef.current = {
    onPaid,
    onCancelled,
    onFailed,
    onStatusChange
  };
  const [state, setState] = (0, import_react.useState)({ status: "idle" });
  const supported = contractVersion ? isMethodSupported("payment:request", contractVersion) : true;
  const updateState = (0, import_react.useCallback)((newState) => {
    var _a, _b;
    setState(newState);
    (_b = (_a = callbacksRef.current).onStatusChange) == null ? void 0 : _b.call(_a, newState.status);
  }, []);
  const pay = (0, import_react.useCallback)(async (params) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (!isBridgeAvailable$1) {
      const error = new Error("Bridge is not available. Running in dev mode?");
      console.warn("[@alien_org/react]", error.message);
      const result = {
        status: "failed",
        errorCode: "unknown",
        error
      };
      updateState(result);
      (_b = (_a = callbacksRef.current).onFailed) == null ? void 0 : _b.call(_a, "unknown", error);
      return result;
    }
    if (contractVersion && !isMethodSupported("payment:request", contractVersion)) {
      const error = new MethodNotSupportedError("payment:request", contractVersion, getMethodMinVersion("payment:request"));
      const result = {
        status: "failed",
        errorCode: "unknown",
        error
      };
      updateState(result);
      (_d = (_c = callbacksRef.current).onFailed) == null ? void 0 : _d.call(_c, "unknown", error);
      return result;
    }
    updateState({ status: "loading" });
    try {
      const response = await request("payment:request", params, "payment:response", { timeout });
      if (response.status === "paid") {
        const txHash = response.txHash ?? "";
        const result$1 = {
          status: "paid",
          txHash
        };
        updateState(result$1);
        (_f = (_e = callbacksRef.current).onPaid) == null ? void 0 : _f.call(_e, txHash);
        return result$1;
      }
      if (response.status === "cancelled") {
        const result$1 = { status: "cancelled" };
        updateState(result$1);
        (_h = (_g = callbacksRef.current).onCancelled) == null ? void 0 : _h.call(_g);
        return result$1;
      }
      const errorCode = response.errorCode ?? "unknown";
      const result = {
        status: "failed",
        errorCode
      };
      updateState(result);
      (_j = (_i = callbacksRef.current).onFailed) == null ? void 0 : _j.call(_i, errorCode);
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      if (err instanceof BridgeError) console.warn("[@alien_org/react] Bridge error:", err.message);
      const result = {
        status: "failed",
        errorCode: "unknown",
        error
      };
      updateState(result);
      (_l = (_k = callbacksRef.current).onFailed) == null ? void 0 : _l.call(_k, "unknown", error);
      return result;
    }
  }, [
    isBridgeAvailable$1,
    contractVersion,
    timeout,
    updateState
  ]);
  const reset = (0, import_react.useCallback)(() => {
    updateState({ status: "idle" });
  }, [updateState]);
  return (0, import_react.useMemo)(() => ({
    status: state.status,
    isLoading: state.status === "loading",
    isPaid: state.status === "paid",
    isCancelled: state.status === "cancelled",
    isFailed: state.status === "failed",
    txHash: state.txHash,
    errorCode: state.errorCode,
    error: state.error,
    pay,
    reset,
    supported
  }), [
    state,
    pay,
    reset,
    supported
  ]);
}
export {
  AlienProvider,
  BridgeError,
  BridgeTimeoutError,
  BridgeUnavailableError,
  BridgeWindowUnavailableError,
  MethodNotSupportedError,
  ReactSDKError,
  getMethodMinVersion,
  isMethodSupported,
  send,
  useAlien,
  useClipboard,
  useEvent,
  useIsMethodSupported,
  useLaunchParams,
  useMethod,
  usePayment
};
//# sourceMappingURL=@alien_org_react.js.map
